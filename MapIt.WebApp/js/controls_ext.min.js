'use strict';

L.Control.Angular = L.Control.extend({
    options: {
        position: 'bottomleft',
        template: ''
    },
    onAdd: function onAdd(map) {
        var that = this;
        this._container = L.DomUtil.create('div', 'angular-control-leaflet');

        if (!L.Browser.touch) {
            L.DomEvent
              .disableClickPropagation(this._container)
              .disableScrollPropagation(this._container);
        } else {
            L.DomEvent.disableClickPropagation(this._container);
        }

        angular.element(document).ready(function () {
            var $injector = angular.element(document).injector();

            if (!$injector) {
                $injector = angular.element(document.querySelectorAll('[ng-app]')).injector();
            }

            if (!$injector) {
                throw "L.Control.Angular can't find your Angular app";
            }

            var $rootScope = $injector.get('$rootScope'),
                $compile = $injector.get('$compile'),
                $controller = $injector.get('$controller');

            that._scope = $rootScope.$new(true);

            var element = angular.element(that._container);
            element.html(that.options.template);

            if (that.options.controller) {
                var controller = $controller(that.options.controller, {
                    '$map': map,
                    '$scope': that._scope,
                    '$element': element,
                    '$options': that.options,
                    '$rootScope': $rootScope
                });

                if (that.options.controllerAs) {
                    that._scope[that.options.controllerAs] = controller;
                }

                element.data('$ngControllerController', controller);
                element.children().data('$ngControllerController', controller);
            }

            $compile(element)(that._scope);
            //that._scope.$apply();
        });
        return this._container;
    },
    onRemove: function () {
        if (this._scope) {
            this._scope.$destroy();
        }
    }
});

L.control.angular = function (options) {
    return new L.Control.Angular(options);
};
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        //AMD
        define(['leaflet'], factory);
    } else if (typeof module !== 'undefined') {
        // Node/CommonJS
        module.exports = factory(require('leaflet'));
    } else {
        // Browser globals
        if (typeof window.L === 'undefined')
            throw 'Leaflet must be loaded first';
        factory(window.L);
    }
})(function (L) {

    function _getPath(obj, prop) {
        var parts = prop.split('.'),
            last = parts.pop(),
            len = parts.length,
            cur = parts[0],
            i = 1;

        if (len > 0)
            while ((obj = obj[cur]) && i < len)
                cur = parts[i++];

        if (obj)
            return obj[last];
    }

    function _isObject(obj) {
        return Object.prototype.toString.call(obj) === "[object Object]";
    }

    //TODO implement can do research on multiple sources layers and remote		
    //TODO history: false,		//show latest searches in tooltip		
    //FIXME option condition problem {autoCollapse: true, markerLocation: true} not show location
    //FIXME option condition problem {autoCollapse: false }
    //
    //TODO here insert function that search inputText FIRST in _recordsCache keys and if not find results.. 
    //  run one of callbacks search(sourceData,jsonpUrl or options.layerGroup) and run this.showTooltip
    //
    //TODO change structure of _recordsCache
    //	like this: _recordsCache = {"text-key1": {loc:[lat,lng], ..other attributes.. }, {"text-key2": {loc:[lat,lng]}...}, ...}
    //	in this mode every record can have a free structure of attributes, only 'loc' is required
    //TODO important optimization!!! always append data in this._recordsCache
    //  now _recordsCache content is emptied and replaced with new data founded
    //  always appending data on _recordsCache give the possibility of caching ajax, jsonp and layersearch!
    //
    //TODO here insert function that search inputText FIRST in _recordsCache keys and if not find results.. 
    //  run one of callbacks search(sourceData,jsonpUrl or options.layerGroup) and run this.showTooltip
    //
    //TODO change structure of _recordsCache
    //	like this: _recordsCache = {"text-key1": {loc:[lat,lng], ..other attributes.. }, {"text-key2": {loc:[lat,lng]}...}, ...}
    //	in this way every record can have a free structure of attributes, only 'loc' is required

    L.Control.Search = L.Control.extend({
        includes: L.Mixin.Events,
        //
        //	Name					Data passed			   Description
        //
        //Managed Events:
        //	search:locationfound	{latlng, title, layer} fired after moved and show markerLocation
        //	search:expanded			{}					   fired after control was expanded
        //  search:collapsed		{}					   fired after control was collapsed
        //
        //Public methods:
        //  setLayer()				L.LayerGroup()         set layer search at runtime
        //  showAlert()             'Text message'         show alert message
        //  searchText()			'Text searched'        search text by external code
        //
        options: {
            url: '',						//url for search by ajax request, ex: "search.php?q={s}". Can be function that returns string for dynamic parameter setting
            layer: null,					//layer where search markers(is a L.LayerGroup)				
            sourceData: null,				//function that fill _recordsCache, passed searching text by first param and callback in second				
            //TODO implements uniq option 'sourceData' that recognizes source type: url,array,callback or layer				
            jsonpParam: null,				//jsonp param name for search by jsonp service, ex: "callback"
            propertyLoc: 'loc',				//field for remapping location, using array: ['latname','lonname'] for select double fields(ex. ['lat','lon'] ) support dotted format: 'prop.subprop.title'
            propertyName: 'ElementName',			//property in marker.options(or feature.properties for vector layer) trough filter elements in layer,
            formatData: null,				//callback for reformat all data from source to indexed data object
            filterData: null,				//callback for filtering data from text searched, params: textSearch, allRecords
            moveToLocation: null,			//callback run on location found, params: latlng, title, map
            buildTip: null,					//function that return row tip html node(or html string), receive text tooltip in first param
            container: '',					//container id to insert Search Control		
            zoom: 12,						//default zoom level for move to location
            minLength: 1,					//minimal text length for autocomplete
            initial: true,					//search elements only by initial text
            casesensitive: false,			//search elements in case sensitive text
            autoType: true,					//complete input with first suggested result and select this filled-in text.
            delayType: 200,					//delay while typing for show tooltip
            tooltipLimit: -1,				//limit max results to show in tooltip. -1 for no limit, 0 for no results
            tipAutoSubmit: true,			//auto map panTo when click on tooltip
            firstTipSubmit: false,			//auto select first result con enter click
            autoResize: true,				//autoresize on input change
            collapsed: true,				//collapse search control at startup
            autoCollapse: false,			//collapse search control after submit(on button or on tips if enabled tipAutoSubmit)
            autoCollapseTime: 1200,			//delay for autoclosing alert and collapse after blur
            textErr: 'Location not found',	//error message
            textCancel: 'Cancel',		    //title in cancel button		
            textPlaceholder: 'Search...',   //placeholder value			
            position: 'topleft',
            hideMarkerOnCollapse: false,    //remove circle and marker on search control collapsed		
            marker: {						//custom L.Marker or false for hide
                icon: false,				//custom L.Icon for maker location or false for hide
                animate: true,				//animate a circle over location found
                circle: {					//draw a circle in location found
                    radius: 7,
                    weight: 3,
                    color: 'yellow',
                    stroke: true,
                    fill: false
                }
            },
            flagIcon: L.icon({
                iconUrl: '/mapit/images/flag-icon.png', //shadowUrl: 'my-icon-shadow.png',
                iconSize: [33, 36],
                iconAnchor: [0, 36],
                popupAnchor: [0, -36] //shadowSize: [68, 95],shadowAnchor: [22, 94]
            }),
            afterSearch: function () { }
        },

        initialize: function (options) {
            L.Util.setOptions(this, options || {});
            this._inputMinSize = this.options.textPlaceholder ? this.options.textPlaceholder.length : 10;
            this._layer = this.options.layerGroup || new L.LayerGroup();
            this._filterData = this.options.filterData || this._defaultFilterData;
            this._formatData = this.options.formatData || this._defaultFormatData;
            this._moveToLocation = this.options.moveToLocation || this._defaultMoveToLocation;
            this._autoTypeTmp = this.options.autoType;	//useful for disable autoType temporarily in delete/backspace keydown
            this._countertips = 0;		//number of tips items
            this._recordsCache = {};	//key,value table! that store locations! format: key,latlng
            this._curReq = null;
        },

        onAdd: function (map) {
            var that = this;
            that._injector = undefined;
            that._filterSearch = this.options.propertyName;
            that._map = map;
            that._container = L.DomUtil.create('div', 'leaflet-control-search');

            that._isLoading = false;
            that._isLoading_interval = null;
            that.displayLoading = function (isLoading) {
                var countLeft = 100;

                L.DomUtil.addClass(this._container, 'search-load');

                if (isLoading !== undefined && isLoading === false) {
                    setTimeout(function () {
                        L.DomUtil.removeClass(this._container, 'search-load');
                        clearInterval(this._isLoading_interval);
                    }.bind(this), 1000);
                }

                //this._isLoading_interval = setInterval(function () {
                //    L.DomUtil.addClass(this._container, 'search-load');
                //    --countLeft;
                //    if (countLeft <= 0 && !this._isLoading) {
                //        L.DomUtil.removeClass(this._container, 'search-load');
                //        clearInterval(this._isLoading_interval);
                //    }
                //}.bind(this),20);
            };

            that._scope = {
                searchFilters: [
                    { id: 0, name: "Address", field: "Address", tooltip: "geocoder", value: undefined, inputFormat: "" },
                    { id: 1, name: "Name", field: "ElementName", tooltip: "Element name", value: undefined, inputFormat: "" },
                    { id: 2, name: "Folder", field: "FolderName", tooltip: "Folder (asmade name)", value: undefined, inputFormat: "" },
                    { id: 3, name: "File", field: "FileName", tooltip: "File name (dwg)", value: undefined, inputFormat: "" },
                    { id: 4, name: "Lat,Lng", field: "Latitude,Longitude", tooltip: "Latitude(°, North), Longitude(°, East)", value: undefined, inputFormat: "" },
                    { id: 5, name: "X,Y", field: "X,Y", tooltip: "Latitude(m, North), Longitude(m, East)", value: undefined, inputFormat: "" }
                ], "inputText": undefined
            };

            this._scope.searchFilterSelected = this._scope.searchFilters[0];
            this._scope.searchFilters.getByName = function (name) {
                for (var i = 0; i < that._scope.searchFilters.length; i++) {
                    if (that._scope.searchFilters[i].name === name) {
                        return $scope.searchFilters[i];
                    }
                }
            };

            var searchController = function ($compile, $rootScope, $scope, $filter, $injector, config) {
                $rootScope.counter = 0;

                that._injector = $injector;

                angular.extend($rootScope, that._scope);

                $rootScope.dropboxitemselected = function (item) {
                    that._scope.searchFilterSelected = item;
                    angular.extend($rootScope, that._scope);
                    that._geocoder.display(item.field === "Address");
                    //templateCompileController($scope, $compile);
                };

                $rootScope.search = function (inputText) {
                    var marker, markerData, centerPoint, inputParams;
                    switch ($scope.searchFilterSelected.name) {
                        case "Name":
                        case "File":
                        case "Folder":
                            break;
                        case "Adress":
                            break;
                    }
                    //app.displayPopup(marker || centerPoint);
                }

                $scope.inputchange = function () {
                    $scope.counter++;
                };

                function compile(element) {
                    var el = angular.element(element);
                    $scope = el.scope();
                    $injector = el.injector();
                    $injector.invoke(function ($compile) {
                        $compile(el)($scope);
                    });
                }

                angular.extend(that._scope, $rootScope);
            }

            var dropdownAngularControl = L.control.angular({
                position: 'topleft',
                template: ['<span class="input-group-btn search-dropdown" >',
                    '<a href="#" id="markerTypeDropdownMenu" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">',
                    '<button class="btn btn-default mapit-content-control-dropdown" type="button">',
                    '<span>{{$root.searchFilterSelected.name}}</span><span class="caret"></span>',
                    '</button></a>',
                    '<ul class="dropdown-menu" aria-labelledby="markerTypeDropdownMenu">',
                    '<li ng-repeat="searchFilter in $root.searchFilters"><a class="dropdownitem" ng-click="$root.dropboxitemselected(searchFilter)">{{searchFilter.name}}</a></li>',
                    '<li role="separator" class="divider"></li>',
                    //'<li><a id="filterCmb" href="#" ng-click="$root.dropboxitemselected()">Adress</a></li>',
                    '</ul></span>'
                ].join(""),
                controller: ["$compile", "$rootScope", "$scope", "$filter", "$injector", "config", searchController]
            });
            map.addControl(dropdownAngularControl);

            this._dropdown = this._createDropDown('search-dropdown');
            this._dropdown.appendChild(dropdownAngularControl.getContainer());
            this._input = this._createInput(this.options.textPlaceholder, 'search-input');
            this._tooltip = this._createTooltip('search-tooltip');
            this._cancel = this._createCancel(this.options.textCancel, 'search-cancel');
            this._button = this._createButton(this.options.textPlaceholder, 'search-button');
            this._alert = this._createAlert('search-alert');

            //this._opendown = this._createOpendown('research', 'search-opendown');
            //this._spinner = this._createSpinner(this.options.textCancel, 'search-spinner');

            if (this.options.collapsed === false)
                this.expand(this.options.collapsed);

            if (this.options.marker) {

                if (this.options.marker instanceof L.Marker || this.options.marker instanceof L.CircleMarker)
                    this._markerSearch = this.options.marker;

                else if (_isObject(this.options.marker))
                    this._markerSearch = new L.Control.Search.Marker([0, 0], this.options.marker);

                this._markerSearch._isMarkerSearch = true;
            }

            this.setLayer(this._layer);

            map.on({
                // 		'layeradd': this._onLayerAddRemove,
                // 		'layerremove': this._onLayerAddRemove
                'resize': this._handleAutoresize
            }, this);

            angular.element(document).ready(function () {
                var $injector = angular.element(document).injector();

                if (!$injector) {
                    $injector = angular.element(document.querySelectorAll('[ng-app]')).injector();
                }

                if (!$injector) {
                    throw "L.Control.Angular can't find your Angular app";
                }

                var $rootScope = $injector.get('$rootScope'),
                    $compile = $injector.get('$compile'),
                    $controller = $injector.get('$controller');

                //that._scope = $rootScope.$new(true);

                var element = angular.element(that._container);
                element.html(that.options.template);

                if (that.options.controller) {
                    var controller = $controller(that.options.controller, {
                        '$map': map,
                        '$scope': that._scope,
                        '$element': element,
                        '$options': that.options
                    });

                    if (that.options.controllerAs) {
                        that._scope[that.options.controllerAs] = controller;
                    }

                    element.data('$ngControllerController', controller);
                    element.children().data('$ngControllerController', controller);

                    //L.DomEvent.on(that._dropdown, 'click', function (e) {
                    //    if (e.target.className.indexOf("dropdownitem") >= 0)
                    //        that._scope.dropboxitemselected(e.target);
                    //}, this);
                }

                //$compile(element)(that._scope);
                //that._scope.$apply();
            });

            function when_external_loaded(name, callback) {
                if (window[name]) {
                    callback();
                } else {
                    setTimeout(function () {
                        when_external_loaded(name, callback);
                    }, 100);
                }
            }

            when_external_loaded("google", function () {
                this._geocoder = this._createGeocoder(); //_createGeocoder();
            }.bind(this));

            return this._container;
        },

        addTo: function (map) {

            if (this.options.container) {
                this._container = this.onAdd(map);
                this._wrapper = L.DomUtil.get(this.options.container);
                this._wrapper.style.position = 'relative';
                this._wrapper.appendChild(this._container);
            }
            else
                L.Control.prototype.addTo.call(this, map);

            return this;
        },

        onRemove: function (map) {
            this._recordsCache = {};
            // map.off({
            // 		'layeradd': this._onLayerAddRemove,
            // 		'layerremove': this._onLayerAddRemove
            // 	}, this);
        },

        // _onLayerAddRemove: function(e) {
        // 	//without this, run setLayer also for each Markers!! to optimize!
        // 	if(e.layer instanceof L.LayerGroup)
        // 		if( L.stamp(e.layer) != L.stamp(this._layer) )
        // 			this.setLayer(e.layer);
        // },

        setLayer: function (layer) {	//set search layer at runtime
            //this.options.layerGroup = layer; //setting this, run only this._recordsFromLayer()
            this._layer = layer;
            this._layer.addTo(this._map);
            return this;
        },

        showAlert: function (text) {
            text = text || this.options.textErr;
            this._alert.style.display = 'block';
            this._alert.innerHTML = text;
            clearTimeout(this.timerAlert);
            this.timerAlert = setTimeout(function () {
                this.hideAlert();
            }.bind(this), this.options.autoCollapseTime);
            return this;
        },

        hideAlert: function () {
            this._alert.style.display = 'none';
            return this;
        },

        cancel: function () {
            this._input.value = '';
            this._handleKeypress({ keyCode: 8 });//simulate backspace keypress
            this._input.size = this._inputMinSize;
            this._input.focus();
            this._cancel.style.display = 'none';
            this._hideTooltip();

            if (this._scope.searchFilterSelected.field === "Address") {
                //this._geocoder.set('place', null);
            }

            return this;
        },

        expand: function (toggle) {
            toggle = typeof toggle === 'boolean' ? toggle : true;
            this._input.style.display = 'block';
            this._dropdown.style.display = 'block';
            L.DomUtil.addClass(this._container, 'search-exp');
            if (toggle !== false) {
                this._input.focus();
                this._map.on('dragstart click', this.collapse, this);
                if (this._scope.searchFilterSelected.field === "Address") {
                    this._geocoder.display(true);
                }
                
            }
            this.fire('search:expanded');
            return this;
        },

        collapse: function () {
            this._hideTooltip();
            this.cancel();
            this._alert.style.display = 'none';
            this._input.blur();

            if (this.options.collapsed) {
                this._input.style.display = 'none';
                this._dropdown.style.display = 'none';
                this._cancel.style.display = 'none';

                L.DomUtil.removeClass(this._container, 'search-exp');
                if (this.options.hideMarkerOnCollapse) {
                    this._map.removeLayer(this._markerSearch);
                }
                this._map.off('dragstart click', this.collapse, this);
            }
            this.fire('search:collapsed');
            return this;
        },

        collapseDelayed: function () {	//collapse after delay, used on_input blur
            if (!this.options.autoCollapse) return this;
            clearTimeout(this.timerCollapse);
            this.timerCollapse = setTimeout(function () {
                this.collapse();
            }.bind(), this.options.autoCollapseTime);
            return this;
        },

        collapseDelayedStop: function () {
            clearTimeout(this.timerCollapse);
            return this;
        },

        cleanInputInfo: function () {
            setTimeout(function () {
                L.DomUtil.removeClass(this._container, 'search-cancel');
            }.bind(this), 2000);
            return this;
        },

        showLocation: function (latlng, title) {	//set location on map from _recordsCache
            var self = this;

            //display markerSearch and goto streetView
            self._map.once('moveend zoomend', function (e) {

                if (self._markerSearch) {
                    self._markerSearch.addTo(self._map).setLatLng(latlng);

                    if (self._markerFlag)
                        self._map.removeLayer(self._markerFlag);

                    self._markerFlag = L.marker(latlng,
                        {
                            icon: self.options.flagIcon,
                            entityType: "flagMarker",
                            data: undefined,
                            controls: new L.LayerGroup([])
                        }).addTo(self._map);

                    app.streetView.load(latlng);
                }
            });

            self._moveToLocation(latlng, title, self._map);

            //FIXME autoCollapse option hide self._markerSearch before that visualized!!
            if (self.options.autoCollapse)
                self.collapse();

            return self;
        },

        // *************** start DOM creations **********

        _createAlert: function (className) {
            var alert = L.DomUtil.create('div', className, this._container);
            alert.style.display = 'none';

            L.DomEvent
                .on(alert, 'click', L.DomEvent.stop, this)
                .on(alert, 'click', this.hideAlert, this);

            return alert;
        },

        _createDropDown: function (className) {

            var dropDown = L.DomUtil.create('span', className, this._container);
            dropDown.style.display = 'none';//dropDown.innerHTML = $(controlAngular)[0].outerHTML;

            L.DomEvent
                .disableClickPropagation(dropDown)
                .on(dropDown, 'blur', this.collapseDelayed, this)
                .on(dropDown, 'focus', this.collapseDelayedStop, this)
                .on(dropDown, 'mouseover', L.DomEvent.stop, this)
                .on(dropDown, 'mouseover', function () {
                    this._hideTooltip();
                }, this);

            return dropDown;
        },

        _createInput: function (text, className) {
            var label = L.DomUtil.create('label', className, this._container);
            var input = L.DomUtil.create('input', className, this._container);

            input.type = 'text';
            input.size = this._inputMinSize;
            input.value = '';
            input.autocomplete = 'off';
            input.autocorrect = 'off';
            input.autocapitalize = 'off';
            input.placeholder = text;
            input.style.display = 'none';
            input.role = 'search';
            input.id = input.role + input.type + input.size;
            input.setAttribute('ng-model', "inputText");
            input.setAttribute('ng-change', "inputchange(inputText)");
            input.maxWidth = "100%";

            label.htmlFor = input.id;
            label.style.display = 'none';
            label.value = text;

            L.DomEvent
                .disableClickPropagation(input)
                .addListener(input, 'keydown', this._handleKeypress, this)
                //.on(input, 'keydown', this._handleKeypress, this)
                .on(input, 'blur', this.collapseDelayed, this)
                .on(input, 'focus', this.collapseDelayedStop, this)
                .on(input, 'focus', this.cleanInputInfo, this);

            return input;
        },

        _createOpendown: function (title, className) {
            var opendown = L.DomUtil.create('a', className, this._container);
            opendown.href = '#';
            opendown.title = title;
            opendown.innerHTML = "<span class='caret'></span>";

            L.DomEvent
                .on(opendown, 'click', L.DomEvent.stop, this)
                .on(opendown, 'click', function () {
                    if (this._input.value.length > this.options.minLength)
                        this._fillRecordsCache();
                }, this);

            return opendown;
        },

        _createCancel: function (title, className) {
            var cancel = L.DomUtil.create('a', className, this._container);
            cancel.href = '#';
            cancel.title = title;
            cancel.style.display = 'block';
            //cancel.innerHTML = "<span>&otimes;</span>";//imageless(see css)

            L.DomEvent
                .on(cancel, 'click', L.DomEvent.stop, this)
                .on(cancel, 'click', this.cancel, this);

            return cancel;
        },

        _createSpinner: function (title, className) {
            var spinner = L.DomUtil.create('a', className, this._container);
            spinner.href = '#';
            spinner.title = title;
            spinner.style.display = 'none';
            spinner.innerHTML = "<i class='fa fa-refresh fa-spin fa-1x fa-fw'></i>";

            L.DomEvent
                .on(spinner, 'click', L.DomEvent.stop, this)
                .on(spinner, 'click', this.cancel, this);

            return spinner;
        },

        _createButton: function (title, className) {
            var button = L.DomUtil.create('a', className, this._container);
            button.href = '#';
            button.title = title;

            L.DomEvent
                .on(button, 'click', L.DomEvent.stop, this)
                .on(button, 'click', this._handleSubmit, this)
                .on(button, 'focus', this.collapseDelayedStop, this)
                .on(button, 'blur', this.collapseDelayed, this);

            return button;
        },

        _createTooltip: function (className) {
            var tool = L.DomUtil.create('ul', className, this._container);
            tool.style.display = 'none';

            L.DomEvent
                .disableClickPropagation(tool)
                .on(tool, 'blur', this.collapseDelayed, this)
                .on(tool, 'mousewheel', function (e) {
                    this.collapseDelayedStop();
                    L.DomEvent.stopPropagation(e);//disable zoom map
                }, this)
                .on(tool, 'mouseover', function (e) {
                    this.collapseDelayedStop();
                }, this);
            return tool;
        },

        _createTip: function (text, val) {//val is object in recordCache, usually is Latlng
            var tip;

            if (this.options.buildTip) {
                tip = this.options.buildTip.call(this, text, val); //custom tip node or html string
                if (typeof tip === 'string') {
                    var tmpNode = L.DomUtil.create('div');
                    tmpNode.innerHTML = tip;
                    tip = tmpNode.firstChild;
                }
            }
            else {
                tip = L.DomUtil.create('li', '');
                tip.innerHTML = text;
            }

            L.DomUtil.addClass(tip, 'search-tip');
            tip._text = text; //value replaced in this._input and used by _autoType
            tip.value = val;

            if (this.options.tipAutoSubmit)
                L.DomEvent
                    .disableClickPropagation(tip)
                    .on(tip, 'click', L.DomEvent.stop, this)
                    .on(tip, 'click', function (e) {
                        this._input.value = text;
                        this._handleAutoresize();
                        this._input.focus();
                        this._hideTooltip();
                        this._handleSubmit(e);
                    }, this);

            return tip;
        },

        _createGeocoder: function () {
            var coder = {};
            coder.autocompleteService = undefined;
            coder.display = function (isDisplay) {
                if (isDisplay) {
                    if (this._geocoder.isValueFromInput) {
                        this._geocoder.autocompleteService = new google.maps.places.Autocomplete(this._input);
                        google.maps.event.addListener(geocoder,
                            'place_changed',
                            this._geocoder.onPlaceChanged.bind(this));
                    } else
                        this._geocoder.autocompleteService = new google.maps.places.AutocompleteService();
                } else {
                    this._geocoder.autocompleteService = undefined;
                    if (this._geocoder.isValueFromInput) {
                        google.maps.event.clearInstanceListeners(this._geocoder.autocompleteService);
                        $(".pac-container").remove();
                    }
                }
            }.bind(this);
            coder.isValueFromInput = false;
            coder.onPlaceChanged = function (inputValue, displaySuggestionsCallBack) {
                this._geocoder.autocompleteService.getQueryPredictions({
                    input: (this._geocoder.isValueFromInput) ? this._input.value : inputValue
                },
                    displaySuggestionsCallBack);
            }.bind(this);
            return coder;
        },

        _createAutocompleteBox: function () {
            var geocoder = new google.maps.places.Autocomplete(undefined);
            geocoder.display = function (isDisplay) {
                if (isDisplay) {
                    geocoder = new google.maps.places.Autocomplete(this._input); //, options
                    //geocoder.addListener('place_changed', onPlaceChanged);
                    google.maps.event.addListener(geocoder, 'place_changed', geocoder.onPlaceChanged.bind(this));
                } else {
                    //google.maps.event.removeListener(geocoder._autocompleteListener);
                    google.maps.event.clearInstanceListeners(geocoder);
                    $(".pac-container").remove();
                }
            }.bind(this);

            geocoder.onPlaceChanged2 = function () {
                this._input.focus();
                var e = jQuery.Event("keydown");
                e.which = 13; // # Some key code value
                $(this._input).trigger(e);
                google.maps.event.trigger(this._geocoder, 'place_changed');
            }.bind(this);

            return geocoder;
        },

        _createSearchBox: function () {
            var searchBox = new google.maps.places.SearchBox(this._input);

            searchBox.display = function (isDisplay) {
                if (isDisplay) {
                    searchBox = new google.maps.places.SearchBox(this._input);
                    searchBox.addListener('place_changed', searchBox.onPlaceChanged.bind(this));
                } else {
                    google.maps.event.clearInstanceListeners(searchBox);
                    $(".pac-container").remove();
                }
            }.bind(this);
            searchBox.onPlaceChanged = function () {
                var places = searchBox.getPlaces();
                if (places.length == 0) {
                    return;
                }
                var group = L.featureGroup();
                places.forEach(function (place) {
                    // Create a marker for each place.
                    console.log(places);
                    console.log(place.geometry.location.lat() + " / " + place.geometry.location.lng());
                    var marker = L.marker([
                        place.geometry.location.lat(),
                        place.geometry.location.lng()
                    ]);
                    group.addLayer(marker);
                });
                group.addTo(map);
                map.fitBounds(group.getBounds());
            };
            return searchBox;
        },

        // ********************** end DOM creations ***********

        _getUrl: function (text) {
            return (typeof this.options.url === 'function') ? this.options.url(text) : this.options.url;
        },

        _defaultFilterData: function (text, records) {

            var I, icase, regSearch, frecords = {};

            text = text.replace(/[.*+?^${}()|[\]\\]/g, '');  //sanitize remove all special characters
            if (text === '')
                return [];

            I = this.options.initial ? '^' : '';  //search only initial text
            icase = !this.options.casesensitive ? 'i' : undefined;

            regSearch = new RegExp(I + text, icase);

            //TODO use .filter or .map
            for (var key in records) {
                if (regSearch.test(key))
                    frecords[key] = records[key];
            }

            return frecords;
        },

        showTooltip: function (records) {
            this._countertips = 0;
            this._tooltip.innerHTML = '';
            this._tooltip.currentSelection = -1;  //inizialized for _handleArrowSelect()

            if (this.options.tooltipLimit) {
                if (this._scope.searchFilterSelected.name !== "Address") {
                    for (var key in records) {
                        if (this._countertips === this.options.tooltipLimit)
                            break;
                        this._countertips++;
                        this._tooltip.appendChild(this._createTip(key, records[key]));
                    }
                } else if (this._scope.searchFilterSelected.name === "Address") {
                    records.forEach(function (item, i, arr) {
                        if (i === this.options.tooltipLimit) return false;
                        this._countertips = i;
                        this._tooltip.appendChild(this._createTip(item.placeDescription, item.placeId));
                    }.bind(this));
                }
            }

            if (this._countertips > 0) {
                this._tooltip.style.display = 'block';

                if (this._autoTypeTmp)
                    this._autoType();

                this._autoTypeTmp = this.options.autoType;//reset default value
            }
            else
                this._hideTooltip();

            this._tooltip.scrollTop = 0;

            return this._countertips;
        },

        _hideTooltip: function () {
            this._tooltip.style.display = 'none';
            this._tooltip.innerHTML = '';
            return 0;
        },

        _defaultFormatData: function (json) {	//default callback for format data to indexed data
            var propName = that._scope.searchFilterSelected.field,
                propLoc = this.options.propertyLoc,
                i, jsonret = {};

            if (L.Util.isArray(propLoc))
                for (i in json)
                    jsonret[_getPath(json[i], propName)] = L.latLng(json[i][propLoc[0]], json[i][propLoc[1]]);
            else
                for (i in json)
                    jsonret[_getPath(json[i], propName)] = L.latLng(_getPath(json[i], propLoc));
            //TODO throw new Error("propertyName '"+propName+"' not found in JSON data");
            return jsonret;
        },

        _recordsFromJsonp: function (text, callAfter) {  //extract searched records from remote jsonp service
            L.Control.Search.callJsonp = callAfter;
            var script = L.DomUtil.create('script', 'leaflet-search-jsonp', document.getElementsByTagName('body')[0]),
                url = L.Util.template(this._getUrl(text) + '&' + this.options.jsonpParam + '=L.Control.Search.callJsonp', { s: text }); //parsing url
            //rnd = '&_='+Math.floor(Math.random()*10000);
            //TODO add rnd param or randomize callback name! in recordsFromJsonp
            script.type = 'text/javascript';
            script.src = url;
            return { abort: function () { script.parentNode.removeChild(script); } };
        },

        _recordsFromAjax: function (text, callAfter) {	//Ajax request
            if (window.XMLHttpRequest === undefined) {
                window.XMLHttpRequest = function () {
                    try { return new ActiveXObject("Microsoft.XMLHTTP.6.0"); }
                    catch (e1) {
                        try { return new ActiveXObject("Microsoft.XMLHTTP.3.0"); }
                        catch (e2) { throw new Error("XMLHttpRequest is not supported"); }
                    }
                };
            }
            var IE8or9 = (L.Browser.ie && !window.atob && document.querySelector),
                request = IE8or9 ? new XDomainRequest() : new XMLHttpRequest(),
                url = L.Util.template(this._getUrl(text), { s: text });

            //rnd = '&_='+Math.floor(Math.random()*10000);
            //TODO add rnd param or randomize callback name! in recordsFromAjax			

            request.open("GET", url);
            request.onload = function () {
                callAfter(JSON.parse(request.responseText));
            };
            request.onreadystatechange = function () {
                if (request.readyState === 4 && request.status === 200) {
                    this.onload();
                }
            };

            request.send();
            return request;
        },

        _recordsFromPlaces: function (predictions) {
            var retRecords = [];
            predictions.forEach(function (prediction) {
                retRecords.push({
                    placeDescription: prediction.description,
                    placeId: prediction.place_id,
                    placeLoc: undefined
                });
            });
            return retRecords;
        },

        _recordsFromLayer: function (layerGroup) {	//return table: key,value from layer
            var that = this,
                retRecords = {},
                propName = that._scope.searchFilterSelected.field,
                loc;

            layerGroup.eachLayer(function (layer) {

                if (layer.hasOwnProperty('_isMarkerSearch')) return;

                if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
                    try {
                        if (propName === "Latitude,Longitude") {
                            loc = layer.getLatLng();
                            loc.layer = layer;
                            retRecords[_getPath(layer.options, propName)] = loc;
                        }
                        else if (_getPath(layer.options, propName)) {
                            loc = layer.getLatLng();
                            loc.layer = layer;
                            retRecords[_getPath(layer.options, propName)] = loc;
                        }
                        else if (_getPath(layer.feature.properties.data, propName)) {

                            loc = layer.getLatLng();
                            loc.layer = layer;
                            retRecords[_getPath(layer.feature.properties.data, propName)] = loc;

                        } else
                            throw new Error("propertyName '" + propName + "' not found in marker");

                    }
                    catch (err) {
                        if (console) { console.warn(err); }
                    }
                }
                else if (layer.hasOwnProperty('feature'))//GeoJSON
                {
                    try {
                        if (layer.feature.properties.data.hasOwnProperty(propName)) {
                            loc = layer.getBounds().getCenter();
                            loc.layer = layer;
                            retRecords[layer.feature.properties[propName]] = loc;
                        }
                        else
                            throw new Error("propertyName '" + propName + "' not found in feature");
                    }
                    catch (err) {
                        if (console) { console.warn(err); }
                    }
                }
                else if (layer instanceof L.LayerGroup) {
                    //TODO: Optimize
                    layer.eachLayer(function (m) {
                        loc = m.getLatLng();
                        loc.layer = m;
                        retRecords[m.feature.properties.data[propName]] = loc;
                    });
                }

            }, this);

            return retRecords;
        },

        _autoType: function () {

            //TODO implements autype without selection(useful for mobile device)

            var start = this._input.value.length,
                firstRecord = this._tooltip.firstChild ? this._tooltip.firstChild._text : '',
                end = firstRecord.length;

            if (firstRecord.indexOf(this._input.value) === 0) { // If prefix match
                this._input.value = firstRecord;
                this._handleAutoresize();

                if (this._input.createTextRange) {
                    var selRange = this._input.createTextRange();
                    selRange.collapse(true);
                    selRange.moveStart('character', start);
                    selRange.moveEnd('character', end);
                    selRange.select();
                }
                else if (this._input.setSelectionRange) {
                    this._input.setSelectionRange(start, end);
                }
                else if (this._input.selectionStart) {
                    this._input.selectionStart = start;
                    this._input.selectionEnd = end;
                }
            }
        },

        _hideAutoType: function () {	// deselect text:

            var sel;
            if ((sel = this._input.selection) && sel.empty) {
                sel.empty();
            }
            else if (this._input.createTextRange) {
                sel = this._input.createTextRange();
                sel.collapse(true);
                var end = this._input.value.length;
                sel.moveStart('character', end);
                sel.moveEnd('character', end);
                sel.select();
            }
            else {
                if (this._input.getSelection) {
                    this._input.getSelection().removeAllRanges();
                }
                this._input.selectionStart = this._input.selectionEnd;
            }
        },

        _handleKeypress: function (e) {	//run _input keyup event
            switch (e.keyCode) {
                case 27://Esc
                    this.collapse();
                    break;
                case 13://Enter
                    //if (this._countertips === 1 || (this.options.firstTipSubmit && this._countertips > 0))
                    //    this._handleArrowSelect(1);
                    this._handleSubmit();	//do search
                    break;
                case 38://Up
                    this._handleArrowSelect(-1);
                    break;
                case 40://Down
                    this._handleArrowSelect(1);
                    break;
                //case 45://Insert
                //case 46://Delete
                //    this._autoTypeTmp = false;//disable temporarily autoType
                //    break;
                case 37://Left
                case 39://Right
                case 16://Shift
                case 17://Ctrl
                case 35://End
                case 36://Home
                    break;

                case 45://Insert
                case 46://Delete
                case 8://Backspace
                default://All keys
                    this._cancel.style.display = (this._input.value.length > 0) ? 'block' : 'none';

                    if (this._scope.searchFilterSelected.field === "Latitude,Longitude") {
                        if (this._input.value.indexOf(",") > 0 && this._input.value.length - this._scope.searchFilterSelected.field.indexOf(",") > 2) {
                            var values = this._input.value.split(",");
                            //if (Array.isArray(values)) {
                            //}
                        } else if (/^\d{2}\.\d{0,5}$/.test(this._input.value)) {

                        } else {
                            break;
                        }
                    }
                    else if (this._scope.searchFilterSelected.field === "X,Y") {

                    }
                    else {
                        clearTimeout(this.timerKeypress); //cancel last search request while type in				
                        this.timerKeypress = setTimeout(function () { //delay before request, for limit jsonp/ajax request

                            if (this._input.value.length > this.options.minLength) {

                                if (this._scope.searchFilterSelected.field === "Address") {

                                    this._geocoder.onPlaceChanged(this._input.value,
                                        function (predictions, status) {
                                            if (status != google.maps.places.PlacesServiceStatus.OK) {
                                                //alert(status);
                                                return;
                                            }
                                            this._fillRecordsCache(this._scope.searchFilterSelected, predictions);
                                        }.bind(this));
                                }
                                else
                                    this._fillRecordsCache();
                            } else
                                this._hideTooltip();

                        }.bind(this), this.options.delayType);
                    }
            }

            this._handleAutoresize();
        },

        searchText: function (text) {

            var code = text.charCodeAt(text.length);

            this._input.value = text;

            this._input.style.display = 'block';
            L.DomUtil.addClass(this._container, 'search-exp');

            this._autoTypeTmp = false;

            this._handleKeypress({ keyCode: code });
        },

        _fillRecordsCache: function (searchFilterSelected, data) {

            var inputText = this._input.value,
                that = this, records;

            searchFilterSelected = searchFilterSelected || that._scope.searchFilterSelected;

            //abort previous requests
            if (this._curReq && this._curReq.abort)
                this._curReq.abort();

            L.DomUtil.addClass(this._container, 'search-load');

            setTimeout(function () {
                if (this.options.layerGroup && searchFilterSelected.name === "Address") {
                    records = this._recordsCache = this._recordsFromPlaces(data);
                    this.showTooltip(records);
                }
                else if (this.options.layerGroup && searchFilterSelected.name !== "Address") {
                    //TODO _recordsFromLayer must return array of objects, formatted from _formatData
                    this._recordsCache = this._recordsFromLayer(this.options.layerGroup);

                    records = this._filterData(this._input.value, this._recordsCache);

                    this.showTooltip(records);
                }
                else {
                    if (this.options.sourceData)
                        this._retrieveData = this.options.sourceData;

                    else if (this.options.url)	//jsonp or ajax
                        this._retrieveData = this.options.jsonpParam ? this._recordsFromJsonp : this._recordsFromAjax;

                    if (this._retrieveData)
                        this._curReq = this._retrieveData.call(this, inputText, function (data) {

                            that._recordsCache = that._formatData(data);

                            //TODO refact!
                            if (that.options.sourceData)
                                records = that._filterData(that._input.value, that._recordsCache);
                            else
                                records = that._recordsCache;

                            that.showTooltip(records);
                        });
                }

                setTimeout(function () {
                    L.DomUtil.removeClass(this._container, 'search-load');
                }.bind(this), 500);

            }.bind(this));


        },

        _handleAutoresize: function () {	//autoresize this._input
            //TODO refact _handleAutoresize now is not accurate
            if (this._input.style.maxWidth !== this._map._container.offsetWidth) //If maxWidth isn't the same as when first set, reset to current Map width
                this._input.style.maxWidth = L.DomUtil.getStyle(this._map._container, 'width');

            if (this.options.autoResize && (this._container.offsetWidth + 45 < this._map._container.offsetWidth))
                this._input.size = this._input.value.length < this._inputMinSize ? this._inputMinSize : this._input.value.length;
        },

        _handleArrowSelect: function (velocity) {

            var searchTips = this._tooltip.hasChildNodes() ? this._tooltip.childNodes : [];

            for (i = 0; i < searchTips.length; i++)
                L.DomUtil.removeClass(searchTips[i], 'search-tip-select');

            if ((velocity === 1) && (this._tooltip.currentSelection >= (searchTips.length - 1))) {// If at end of list.
                L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');
            }
            else if ((velocity === -1) && (this._tooltip.currentSelection <= 0)) { // Going back up to the search box.
                this._tooltip.currentSelection = -1;
            }
            else if (this._tooltip.style.display !== 'none') {
                this._tooltip.currentSelection += velocity;

                L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');

                this._input.value = searchTips[this._tooltip.currentSelection]._text;

                // scroll:
                var tipOffsetTop = searchTips[this._tooltip.currentSelection].offsetTop;

                if (tipOffsetTop + searchTips[this._tooltip.currentSelection].clientHeight >= this._tooltip.scrollTop + this._tooltip.clientHeight) {
                    this._tooltip.scrollTop = tipOffsetTop - this._tooltip.clientHeight + searchTips[this._tooltip.currentSelection].clientHeight;
                }
                else if (tipOffsetTop <= this._tooltip.scrollTop) {
                    this._tooltip.scrollTop = tipOffsetTop;
                }
            }
        },

        _handleSubmit: function (e) {	//button and tooltip click and enter submit
            this._hideAutoType();
            this.hideAlert();
            this._hideTooltip();

            if (this._input.style.display === 'none')	//on first click show _input only
                this.expand();
            else {
                if (this._input.value === '')	//hide _input only
                    this.collapse();
                else {
                    L.DomUtil.addClass(this._container, 'search-load');

                    //var localInjector = angular.injector(["ng"]);
                    var $filter = this._injector.get("$filter");

                    var pointResult = undefined;
                    var markerResult = undefined;
                    var display = function (point, marker) {
                        if (this._markerFlag)
                            this._map.removeLayer(this._markerFlag);
                        if (this._markerSearch)
                            this._map.removeLayer(this._markerSearch);

                        if (marker)
                            app.displayPopup(marker, undefined, true);
                        else if (point) {
                            this.showLocation(point, this._input.value);
                            this.fire('search:locationfound',
                                {
                                    latlng: pointResult,
                                    text: this._input.value,
                                    layer: point.layer ? point.layer : null
                                });
                        }

                        setTimeout(function () {
                            L.DomUtil.removeClass(this._container, 'search-cancel');
                            L.DomUtil.removeClass(this._container, 'search-load');
                        }.bind(this), 500);
                    }.bind(this);

                    setTimeout(function () {
                        var selectedValue = this._scope.searchFilterSelected.name;
                        switch (selectedValue) {
                            case "X,Y":
                                var inputParams = this._input.value.split(",");
                                if (inputParams.length === 2) {
                                    pointResult = JSITM.itm2gps({ x: parseFloat(inputParams[0]), y: parseFloat(inputParams[1]) });
                                    markerResult = $filter('filterMarker')(this._scope.searchFilterSelected.name, inputParams);
                                }
                                break;
                            case "Lat,Lng":
                                var inputParams = this._input.value.split(",");
                                if (inputParams.length === 2) {
                                    pointResult = new L.LatLng(parseFloat(inputParams[0]), parseFloat(inputParams[1]));
                                    markerResult = $filter('filterMarker')(this._scope.searchFilterSelected.name, inputParams);
                                }
                                break;
                            case "Address":
                                var service = new google.maps.places.PlacesService(gmap);

                                if (e && e.srcElement && e.srcElement.classList.contains("search-tip")) {
                                    var request = { placeId: e.srcElement.value }
                                    service.getDetails(request, function (place, status) {
                                        if (status == google.maps.places.PlacesServiceStatus.OK) {
                                            pointResult = new L.LatLng(
                                                place.geometry.location.lat(),
                                                place.geometry.location.lng());
                                            display(pointResult);
                                        }
                                    });
                                } else {
                                    //var autocompleteService = new google.maps.places.AutocompleteService();
                                    this._geocoder.autocompleteService.getQueryPredictions({ input: this._input.value },
                                        function (predictions) {
                                            if (predictions.length == 0) return;

                                            if (predictions.length === 1) {
                                                var request = { placeId: predictions[0].place_id }
                                                service.getDetails(request,
                                                    function (place, status) {
                                                        if (status == google.maps.places.PlacesServiceStatus.OK) {
                                                            pointResult = new L.LatLng(
                                                                place.geometry.location.lat(),
                                                                place.geometry.location.lng());
                                                            display(pointResult);
                                                        }
                                                    });
                                            } else {
                                                this._geocoder.onPlaceChanged(this._input.value,
                                                    function (predictions, status) {
                                                        if (status != google.maps.places.PlacesServiceStatus.OK) {
                                                            //alert(status);
                                                            return;
                                                        }
                                                        this._fillRecordsCache(this._scope.searchFilterSelected, predictions);
                                                    }.bind(this));
                                            }

                                        }.bind(this));
                                }

                                break;
                            default:
                                if (Object.keys(this._recordsCache).length === 0) {
                                    this._fillRecordsCache();
                                }
                                else if (!this._recordsCache.hasOwnProperty(this._input.value)) {
                                    this._fillRecordsCache();
                                }
                                else {
                                    markerResult = $filter('filterMarker')(this._scope.searchFilterSelected.name, this._input.value);
                                    pointResult = this._getLocation(this._input.value);

                                    if (pointResult === false) {
                                        this.showAlert();
                                    }
                                    //else {
                                    //    this.showLocation(dispalyPoint, this._input.value);
                                    //    this.fire('search:locationfound', {
                                    //        latlng: dispalyPoint,
                                    //        text: this._input.value,
                                    //        layer: dispalyPoint.layer ? dispalyPoint.layer : null
                                    //    });
                                    //}
                                }
                                break;
                        }

                        if (selectedValue !== "Address") {
                            display(pointResult, markerResult);
                        }

                    }.bind(this), 200);
                }
            }
        },

        _getLocation: function (key) {	//extract latlng from _recordsCache

            if (this._recordsCache.hasOwnProperty(key))
                return this._recordsCache[key];//then after use .loc attribute
            else
                return false;
        },

        _defaultMoveToLocation: function (latlng, title, map) {
            if (map.getZoom() !== this.options.zoom)
                this._map.setView(latlng, map.getZoom());
            else
                this._map.panTo(latlng);
        }
    });

    L.Control.Search.Marker = L.Marker.extend({

        includes: L.Mixin.Events,

        options: {
            icon: new L.Icon.Default(),
            animate: true,
            circle: {
                radius: 7,
                weight: 3,
                color: '#e03',
                stroke: true,
                fill: false
            }
        },

        initialize: function (latlng, options) {
            L.setOptions(this, options);

            if (options.icon === true)
                options.icon = new L.Icon.Default();

            L.Marker.prototype.initialize.call(this, latlng, options);

            if (_isObject(this.options.circle))
                this._circleLoc = new L.CircleMarker(latlng, this.options.circle);
        },

        onAdd: function (map) {
            L.Marker.prototype.onAdd.call(this, map);
            if (this._circleLoc) {
                map.addLayer(this._circleLoc);
                if (this.options.animate)
                    this.animate();
            }
        },

        onRemove: function (map) {
            L.Marker.prototype.onRemove.call(this, map);
            if (this._circleLoc)
                map.removeLayer(this._circleLoc);
        },

        setLatLng: function (latlng) {
            L.Marker.prototype.setLatLng.call(this, latlng);
            if (this._circleLoc)
                this._circleLoc.setLatLng(latlng);
            return this;
        },

        _initIcon: function () {
            if (this.options.icon)
                L.Marker.prototype._initIcon.call(this);
        },

        _removeIcon: function () {
            if (this.options.icon)
                L.Marker.prototype._removeIcon.call(this);
        },

        animate: function () {
            //TODO refact animate() more smooth! like this: http://goo.gl/DDlRs
            if (this._circleLoc) {
                var circle = this._circleLoc,
                    tInt = 200,	//time interval
                    ss = 5,	//frames
                    mr = parseInt(circle._radius / ss),
                    oldrad = this.options.circle.radius,
                    newrad = circle._radius * 2,
                    acc = 0;

                circle._timerAnimLoc = setInterval(function () {
                    acc += 0.5;
                    mr += acc;	//adding acceleration
                    newrad -= mr;

                    circle.setRadius(newrad);

                    if (newrad < oldrad) {
                        clearInterval(circle._timerAnimLoc);
                        circle.setRadius(oldrad);//reset radius
                        //if(typeof afterAnimCall == 'function')
                        //afterAnimCall();
                        //TODO use create event 'animateEnd' in L.Control.Search.Marker 
                    }
                }, tInt);
            }

            return this;
        }
    });

    L.Map.addInitHook(function () {
        if (this.options.searchControl) {
            this.searchControl = L.control.search(this.options.searchControl);
            this.addControl(this.searchControl);
        }
    });

    L.control.search = function (options) {
        return new L.Control.Search(options);
    };

    return L.Control.Search;

});